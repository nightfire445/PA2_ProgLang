module dna;
import java.io.*;
import Tuple;

/* InversionCount.salsa -- Count the number of DNA inversions

*/


behavior InversionCount{


//TODO:

// Determine # of actors,


 /*
      The act(...) message handler is invoked by stand-alone
      theaters automatically and is used to bootstrap salsa
      programs.
*/	String input;
    String target;

    InversionCount(String input){
     	this.input = input;

     }


    Object[] fix_inversion(Object[] input, String target){

    	Object[] arr = new Object[3];
        int inversion_count = 0;


        for(int i = 0; i < target.length; i++){

            if(target[i+1] != NULL && target[i] > target[i+1]){
                String target_temp = target.subSequence(i, i+1);
                String input_temp = input[0].subSequence(i,i+1);
                //Swap indicies, may need to switch to subSequence?
                target[i] = target[i+1];
                target[i+1] = target_temp[0];

                //need to make sure target and input correspond
                input[0][i] = input[0][i+1];
                input[0][i+1] = input_temp[0];

                //begin again at start of the string
                i = 0;
                inversion_count = inversion_count + 1;

            }



        }
		arr[0] = input[0];
        arr[1] = inversion_count + input[1];
        arr[2] = target;


     	return arr;

     }


    Object[] merge( Object[] left_array , Object[] right_array){


     	int merged_num_inversions = left_array[1] + right_array[1];
     	String merged_sequence = left_array[0] + right_array[0];
        String target = left_array[2] + right_array[2];

     	Object[] merged_array = new Object[3];
     	merged_array[0] = merged_sequence;
     	merged_array[1] = merged_num_inversions;
        merged_array[2] = target;
     	
     	
 	//Covers the case when an char on the left (0:N/2) needs to be on the right (N/2+1:N) and vice versa

     	if(merged_sequence.length == target_sequence.length){

     		merged_array = fix_inversion(merged_array, target); 
     	}


     	return merged_array;
     }
      

    String get_string(Object [] input){

        return input[2];

    }


    Object[] recursive_count(){

    	if (input.length == 1){
            Object[] arr = new Object[2];
            arr[0] = input;
            arr[1] = 0;
    		return arr;
    	}
    	else {
    		// Returns a new character sequence constructed from beginIndex index up until endIndex - 1.
			InversionCount left = new InversionCount( input.subSequence(0, input.length/2+1) );
			InversionCount right = new InversionCount( input.subSequence(input.length/2+1, input.length) );
			String left_target = target.subSequence(0, target.length/2+1);
			String right_target = target.subSequence(target.length/2+1, target.length);


            //3 indexed array : input_sans_inversion, #inversions, target_sans_inversion
			token left_input = left <- recursive_count();
			token right_input = right <- recursive_count();

            //the targets set prior to recusive count will not correspond to the sorted input returned
            //needed to write a function to return the string from the array since you cant index a token.
            left_target = get_string(left_input);
            right_target =  get_string(right_input);

            //3 indexed array : input_sans_inversion, #inversions, target_sans_inversion
			token left_array = fix_inversion(left_input, left_target);
			token right_array = fix_inversion(right_input, right_target);

			return merge( left_array, right_array);
    	}


    }



	void act(String args[]){


		if(args.length == 0){
			
			System.out.println("Proper Usage is: salsa dna.InversionCount input.txt");
	        System.exit(0);

		}


		Reader fileReader = new FileReader(args[0]);
		//Input File: 
		//Input Sequence
		//Target Sequence

		String input_sequence = fileReader.read();
		String target_sequence = fileReader.read();

		fileReader.close();

		InversionCount kickoff = new InversionCount(input_sequence);
		//not ideal since the actor value target is only used here but what evs.
		kickoff.target = tomsFunction();
        Object[] answer = new Object[3];
		answer = 	kickoff.recursive_count();
		int test = target_sequence == answer[0] && answer[0] == answer[2];
		assert test;
		System.out.print("InversionCount : ", answer[1]);


	}








}



